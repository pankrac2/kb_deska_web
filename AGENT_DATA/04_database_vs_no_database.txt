================================================================================
ALBUM DOWNLOAD SITE — CAN YOU DO IT WITHOUT A DATABASE? TRADEOFFS
================================================================================

SHORT ANSWER
------------

  - You can avoid a “traditional” database (PostgreSQL, MySQL, etc.).
  - You cannot safely enforce “limited number of downloads” without some form of persistent storage. That storage can be a simple file (JSON/SQLite) or a key-value/blob store used by serverless.

So: “No database” in the sense of “no MySQL/Postgres” = yes. “No storage at all” = no, if you want limits.


OPTION 1: NO DATABASE — USE A FILE (JSON OR SQLITE)
---------------------------------------------------

How it works:
  - One file (e.g. tokens.json or tokens.sqlite) stores: token → { max_downloads, remaining, created_at? }.
  - A small backend (Node/Python on a VPS or PaaS with writable disk) reads this file on each request, checks the token, and optionally decrements “remaining” when a download is triggered.
  - Your “generator” script (run locally or on the server) appends new tokens to this file. No DB server to install or backup in the classical sense.

Pros:
  - No database server; just a file. Easy to backup (copy the file), easy to inspect (open in editor or sqlite3).
  - Simple to add tokens: run script, append to file, redeploy or restart if needed (or script writes directly if same machine).
  - Fits “no backoffice”: you don’t need a UI; you run a script to generate tokens and QR codes.

Cons:
  - Needs a server (or PaaS) with writable disk. Typical serverless (Netlify/Vercel) does not give you persistent writable filesystem, so this option usually means a small VPS or Railway/Render.
  - Concurrency: if two people hit the same link at once, you might decrement twice with a naive read-modify-write. For “band album” traffic this is unlikely; you can accept the risk or use SQLite with a single update (e.g. UPDATE tokens SET remaining = remaining - 1 WHERE token = ? AND remaining > 0).
  - You are responsible for backing up that file.

Safe? Yes, if:
  - Tokens are generated with crypto randomness (e.g. 128-bit).
  - The file is not publicly readable (only your backend reads it).
  - You use HTTPS and, if you want, rate-limit by IP on the download endpoint.


OPTION 2: NO DATABASE — USE SERVERLESS + KV/BLOB
------------------------------------------------

How it works:
  - Netlify Blobs, Vercel KV, Upstash Redis, or Cloudflare KV: store key = token, value = { remaining, … }.
  - Serverless function: on request, get token from URL, look up in KV, return status and optionally decrement.
  - No “database” product; no server to maintain. Token list is seeded once (e.g. by a script that calls an admin endpoint or writes to the store via SDK).

Pros:
  - No server, no disk to manage. Fits “hosted on a domain” with Netlify/Vercel/Cloudflare.
  - Free tiers are usually enough for hundreds/thousands of tokens and low traffic.
  - Atomic decrement is easier (e.g. compare-and-set or increment “used” count).

Cons:
  - You depend on that provider’s KV/Blob. Slightly more “moving parts” than a single file.
  - Seeding tokens: you need a one-off script or a protected endpoint that writes to the store; not a full backoffice, but a clear process to “add 100 new tokens”.

Safe? Yes, same as above: crypto random tokens, token store not public, HTTPS. No extra risk compared to a file; often better durability and concurrency.


OPTION 3: TRULY NO PERSISTENT STORAGE (STATIC ONLY)
---------------------------------------------------

How it would work:
  - Each token is a unique path or query param. The file is stored at a unique, unguessable path (e.g. /files/<token>.zip) or behind a signed URL that’s valid for a long time.
  - No server logic that “remembers” how many times someone downloaded. So you cannot enforce “max 1” or “max 3” downloads.

Tradeoff:
  - Pros: Easiest — static host, no backend, no DB, no KV.
  - Cons: You do not have “limited downloads.” Anyone with the link can download forever. If the link leaks, you can’t revoke or limit it without changing the file or the URL (e.g. move the file and invalidate the old path).

Verdict: Only choose this if you give up on “limited number of downloads” and accept “unguessable link = secret link, use once in practice because we don’t share it.”


SUMMARY TABLE
-------------

| Approach              | Enforce limit? | Needs server?     | “No DB” (no SQL)? | Best for                          |
|-----------------------|----------------|--------------------|-------------------|------------------------------------|
| File (JSON/SQLite)    | Yes            | Yes (VPS/PaaS)    | Yes               | Simple, one server, full control   |
| Serverless + KV/Blob  | Yes            | No (serverless)   | Yes               | No server, free tier, minimal ops  |
| Static only           | No             | No                | Yes               | Only if you drop “limited” requirement |


RECOMMENDATION
--------------

  - If you want “limited downloads” and “no backoffice”: use either (1) a small backend with one JSON or SQLite file, or (2) serverless + KV/Blob. Both are “no database” in the usual sense and are safe if tokens are strong and the store is not public.
  - If you are OK with “unguessable but unlimited”: static hosting with unique paths or signed URLs is possible with no backend and no DB.

================================================================================
