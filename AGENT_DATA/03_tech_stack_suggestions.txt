================================================================================
ALBUM DOWNLOAD SITE — TECH STACK SUGGESTIONS
================================================================================

FRONTEND STACK
--------------

Goals: main page + download page, easy to restyle to match konaboj.cz, minimal.

Option A — Simple static HTML + CSS (+ optional tiny JS)
  - Pros: No build step, easy to edit in any editor, works everywhere, fast.
  - Cons: Download page “status” (used / remaining) and “download button” need either a backend or a separate API; you’d still need a small backend for token check and file delivery.
  - Best if: You want maximum simplicity and are OK with a bit of JS to call an API for “is this token valid / how many left?” and “give me the file”.

Option B — Static site generator (e.g. 11ty, Astro) + HTML/CSS
  - Pros: Still static output, but you can use templates and a config (e.g. colours, band name) so “editing to match band style” is changing config + assets, not raw HTML.
  - Cons: Build step; need to redeploy when content changes.
  - Best if: You want a bit of structure and theming without a heavy framework.

Option C — Lightweight SPA (e.g. React/Vue/Svelte) + static export or small API
  - Pros: Nice UX (e.g. show “Checking…” then “Download” or “Already used”), component-based styling.
  - Cons: More tooling, overkill if you only have two pages.
  - Best if: You plan to add more interactivity or already use one of these.

Recommendation: Option A or B. For “main page + one download page type” and “easily editable to match band,” static HTML (or 11ty/Astro with a simple config and CSS variables for colours/fonts) is enough. Use a single “download page” that reads the token from the URL (e.g. /download/[token]) and calls a small backend/API to get status and the download link.


BACKEND STACK
-------------

You need:
  1. Validate token (does it exist?).
  2. Return remaining downloads (or “used”).
  3. Decrement remaining (or mark used) when user starts download.
  4. Serve the file (or redirect to a signed URL).

Option A — Serverless functions (Netlify / Vercel / Cloudflare Workers) + KV/Blob
  - Netlify: Netlify Functions + Netlify Blobs (or external Upstash Redis).
  - Vercel: Vercel Functions + Vercel KV (or Upstash).
  - Workers: Cloudflare Workers + KV or D1.
  - Pros: No server to maintain, scales, free tiers. “No database” in the sense of no PostgreSQL/MySQL.
  - Cons: Cold starts, need to store tokens and counts in KV/Blob; token list must be seeded (e.g. by a one-off script that writes to the store).

Option B — Minimal backend on a VPS or PaaS (Node.js or Python)
  - One process: serves static site (or you host static elsewhere) and exposes e.g. GET /api/download/:token (status) and POST/GET to trigger download and decrement.
  - Store: single JSON file or SQLite on disk. No “database server.”
  - Pros: Full control, simple file-based persistence, easy to run a “generator” script on the same machine that appends new tokens to the file.
  - Cons: You manage one server (or use Railway/Render and still get a single process + disk).

Option C — Hybrid: static on Netlify/Vercel, “backend” as serverless + Blob/KV
  - Same as A; frontend is static site on same host.
  - Generator script runs locally: generates tokens, uploads initial list to Blob/KV (or you have a one-off “seed” function), and generates QR images with node-qrcode.

Recommendation: A or C if you want zero server ops. B if you prefer one simple server and a JSON/SQLite file and are OK with a tiny VPS or Railway/Render.


QR CODE GENERATION
------------------

  - For “generate new QR codes with unique link” you need a repeatable process that produces one image per token.
  - Best fit: small Node.js script using “qrcode” (node-qrcode):
    - Input: list of tokens (or generate N new tokens).
    - Output: folder of PNGs (or SVGs), filenames e.g. token_abc123.png or booklet_001.png.
  - No backoffice: run the script when you need a new batch (e.g. before a print run), then send the images to the printer or drop into the booklet layout.
  - Optional: Use QuickChart or similar API only if you prefer not to run Node; then each unique URL is just a different text= parameter. For bulk and no external dependency, local node-qrcode is better.

Summary:
  - Frontend: Static HTML (or 11ty/Astro) + CSS, optionally minimal JS to call API for download status/link.
  - Backend: Serverless + KV/Blob (Netlify/Vercel/Workers) or small Node/Python server + JSON/SQLite.
  - QR: node-qrcode in a local script; input = tokens or URLs, output = folder of QR images.

================================================================================
